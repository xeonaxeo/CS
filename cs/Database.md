# 데이터베이스(Database)

## 데이터베이스 개요

### 데이터베이스의 정의와 필요성

- **정의**: 데이터베이스(Database)는 체계적으로 조직화된 데이터의 모음으로, 특정 응용 프로그램이나 사용자가 효율적으로 데이터를 관리하고 접근할 수 있도록 지원합니다.
- **필요성**:
    - 데이터 저장과 관리를 체계화하여 효율성 증대.
    - 데이터 중복 최소화 및 일관성 보장.
    - 다수의 사용자가 동시에 데이터를 사용 가능.

### 파일 시스템과 데이터베이스의 차이

- **파일 시스템**: 데이터가 파일 단위로 관리되며 독립적.
    - 데이터 중복과 일관성 문제가 발생할 수 있음.
    - 데이터 접근 속도가 느리고 복잡한 질의 처리 어려움.
- **데이터베이스**: 데이터를 통합적으로 관리하고, 고급 검색 및 관리 기능 제공.
    - 데이터 중복 최소화.
    - 동시성 제어와 트랜잭션 지원.

### 데이터베이스의 특징

1. **무결성(Integrity)**: 데이터의 정확성과 일관성을 보장.
2. **일관성(Consistency)**: 모든 트랜잭션이 완료되면 데이터는 일관된 상태를 유지.
3. **보안(Security)**: 데이터 접근을 제한하여 권한 있는 사용자만 접근 가능.

### 데이터베이스 관리 시스템(DBMS)의 역할과 구조

- **역할**:
    - 데이터의 저장, 검색, 갱신, 삭제 작업 제공.
    - 다중 사용자 환경에서 동시성과 무결성 관리.
- **구조**:
    - 논리적 계층: 데이터 모델링과 질의 실행 처리.
    - 물리적 계층: 데이터를 물리적으로 저장하고 관리.

### 데이터베이스 모델의 종류

1. **관계형 모델**: 데이터를 표 형태로 구성하며, SQL을 사용.
2. **비관계형 모델(NoSQL)**: 대규모 비정형 데이터를 관리.
3. **계층형 모델**: 트리 구조를 기반으로 데이터 저장.
4. **네트워크형 모델**: 다대다 관계를 지원하는 구조.

---

## 데이터 모델링

### 데이터 모델링 개념과 프로세스

- **개념**: 데이터를 구조화하여 데이터베이스 설계의 기반을 마련하는 과정.
- **프로세스**:
    1. 요구 사항 분석.
    2. ER 다이어그램 작성.
    3. 정규화.
    4. 물리적 설계로 전환.

### ER(Entity-Relationship) 다이어그램

- **엔터티(Entity)**: 데이터의 객체.
- **속성(Attribute)**: 객체의 특성.
- **관계(Relationship)**: 객체 간의 연관성.

### 정규화

1. **제1정규형(1NF)**: 모든 속성이 원자값을 가짐.
2. **제2정규형(2NF)**: 부분 종속성 제거.
3. **제3정규형(3NF)**: 이행 종속성 제거.
4. **BCNF**: 결정자가 후보 키가 아닌 경우 제거.
5. **제5정규형(5NF)**: 다치 종속성 제거.

### 비정규화와 성능 최적화

- 데이터 중복을 허용해 성능을 높이는 과정.

---

## 관계형 데이터베이스

### 개념

- 데이터를 행(Row)과 열(Column)로 구성된 표(테이블)로 관리.

### 키의 종류

1. **기본 키(Primary Key)**: 테이블의 각 행을 유일하게 식별.
2. **후보 키(Candidate Key)**: 기본 키로 선택 가능한 속성 집합.
3. **외래 키(Foreign Key)**: 다른 테이블의 기본 키를 참조.

### 릴레이션 연산

1. **셀렉션(Selection)**: 조건에 따라 행 선택.
2. **프로젝션(Projection)**: 특정 열 선택.
3. **조인(Join)**: 두 개 이상의 테이블 결합.

### 집합 연산

1. **합집합(Union)**: 두 릴레이션의 모든 튜플 결합.
2. **교집합(Intersection)**: 공통 튜플만 선택.
3. **차집합(Difference)**: 한 릴레이션에만 존재하는 튜플 선택.

---

## SQL

### SQL의 개요와 구성

- **SQL(Structured Query Language)**: 관계형 데이터베이스를 관리하기 위한 언어.

### 데이터 정의 언어(DDL)

- **CREATE**: 테이블, 뷰, 스키마 생성.
- **ALTER**: 테이블 구조 변경.
- **DROP**: 테이블, 뷰 삭제.

### 데이터 조작 언어(DML)

- **SELECT**: 데이터 검색.
- **INSERT**: 데이터 삽입.
- **UPDATE**: 데이터 수정.
- **DELETE**: 데이터 삭제.
```c
sqlite3 *db;
sqlite3_open("example.db", &db);
sqlite3_exec(db, "CREATE TABLE test (id INT, value TEXT);", NULL, NULL, NULL);
sqlite3_exec(db, "INSERT INTO test VALUES (1, 'Hello');", NULL, NULL, NULL);
sqlite3_close(db);
```
### 데이터 제어 언어(DCL)

- **GRANT**: 권한 부여.
- **REVOKE**: 권한 회수.

### 트랜잭션 제어 언어(TCL)

- **COMMIT**: 트랜잭션 확정.
- **ROLLBACK**: 트랜잭션 취소.
- **SAVEPOINT**: 중간 저장점 설정.

---

## 트랜잭션과 동시성 제어

### 트랜잭션의 개념과 ACID 특성

1. **원자성(Atomicity)**: 트랜잭션은 모두 수행되거나 모두 취소.
2. **일관성(Consistency)**: 트랜잭션 완료 후 데이터는 일관된 상태.
3. **격리성(Isolation)**: 트랜잭션 간 간섭 방지.
4. **지속성(Durability)**: 완료된 트랜잭션은 영구히 반영.

### 동시성 문제

1. **갱신 손실**: 두 트랜잭션이 동일 데이터를 동시에 수정.
2. **비일관성 읽기**: 트랜잭션이 수정 중인 데이터를 다른 트랜잭션이 읽음.
3. **비반복 읽기**: 한 트랜잭션 동안 데이터가 변경.

### 격리 수준

1. **Read Uncommitted**
2. **Read Committed**
3. **Repeatable Read**
4. **Serializable**
```c
sqlite3_exec(db, "BEGIN TRANSACTION;", NULL, NULL, NULL);
sqlite3_exec(db, "INSERT INTO test VALUES (2, 'Transaction Test');", NULL, NULL, NULL);
sqlite3_exec(db, "COMMIT;", NULL, NULL, NULL);
```
---

## 데이터베이스 설계

### 설계 단계

1. **요구사항 분석**: 사용자 요구 분석 및 목표 설정.
2. **논리적 설계**: ER 다이어그램 작성 및 정규화 수행.
3. **물리적 설계**: 저장소 구조 및 인덱스 설계.

### 스키마 설계

1. **개념 스키마**: 전체 데이터베이스 구조 정의.
2. **논리 스키마**: 데이터 모델에 기반한 설계.
3. **물리 스키마**: 실제 저장소에 대한 설계.

### 인덱스 설계

1. **클러스터드 인덱스**: 데이터 정렬 및 저장.
2. **비클러스터드 인덱스**: 추가적인 데이터 구조 생성.
3. **B-Tree와 Hash 인덱스**: 효율적인 검색 구조.

---

## 데이터 무결성과 보안

### 무결성 제약 조건

1. **기본 키**: 중복되지 않으며 NULL 값을 가질 수 없음.
2. **외래 키**: 참조 무결성을 보장.
3. **고유성**: 중복 데이터 방지.
4. **도메인**: 속성 값의 유효 범위 정의.

### 보안과 권한 관리

1. **사용자 인증**: 데이터 접근 권한 부여.
2. **역할 기반 접근**: 역할에 따라 권한 분리.
3. **데이터 암호화**: 데이터 보안 강화.
```c
sqlite3_exec(db, "CREATE TABLE test (id INT PRIMARY KEY, value TEXT);", NULL, NULL, NULL);
```
---

## 데이터베이스 성능 최적화

### 실행 계획 분석

- 쿼리 실행 과정 분석 및 병목현상 식별.

### 쿼리 최적화

1. **인덱스 활용**: 검색 속도 향상.
2. **정규화와 비정규화 균형**: 성능과 무결성 간의 균형 유지.

### 파티셔닝

1. **수평 파티셔닝**: 행 기준 분할.
2. **수직 파티셔닝**: 열 기준 분할.

### 샤딩과 데이터 분산

- 데이터베이스를 다수의 노드로 분산 저장.
```c
sqlite3_exec(db, "EXPLAIN QUERY PLAN SELECT * FROM test;", NULL, NULL, NULL);
```
---

## 비관계형 데이터베이스(NoSQL)

### 개요와 특징

- **특징**: 유연한 스키마, 대규모 데이터 처리에 적합.

### 유형

1. **키-값 저장소**: Redis, DynamoDB.
2. **문서형 데이터베이스**: MongoDB, CouchDB.
3. **열 기반 데이터베이스**: Cassandra, HBase.
4. **그래프 데이터베이스**: Neo4j.

### CAP 이론과 BASE 모델

- **CAP 이론**: 일관성, 가용성, 파티션 허용성 간 트레이드오프.
- **BASE 모델**: 가용성과 성능에 중점.
```c
redisContext *c = redisConnect("127.0.0.1", 6379);
redisCommand(c, "SET key 'value'");
redisReply *reply = redisCommand(c, "GET key");
printf("Value: %s\n", reply->str);
redisFree(c);
```
---

## 분산 데이터베이스

### 개념

- 다수의 노드에서 데이터 저장 및 관리.

### 데이터 복제

1. **마스터-슬레이브 복제**: 읽기 작업 분산.
2. **리더-팔로워 복제**: 최신 데이터 복제.

### 분산 트랜잭션

- **2PC(2-Phase Commit)**: 분산 환경에서 트랜잭션 수행 보장.

### 데이터 일관성

- 분산 시스템에서의 데이터 동기화 및 무결성 유지.

## 데이터베이스 관리 및 백업

### 백업 전략

1. **풀 백업**: 전체 데이터 백업.
2. **증분 백업**: 변경된 데이터만 백업.
3. **차등 백업**: 마지막 풀 백업 이후의 모든 데이터 백업.

### 장애 복구

1. **로그 기반 복구**: 트랜잭션 로그를 이용한 복구.
2. **체크포인트**: 복구 시간을 단축하기 위한 저장 지점.

### 데이터베이스 모니터링

- 성능 상태 분석 및 리소스 사용 최적화.

```c
sqlite3_backup *backup = sqlite3_backup_init(destDb, "main", srcDb, "main");
sqlite3_backup_step(backup, -1);
sqlite3_backup_finish(backup);
```